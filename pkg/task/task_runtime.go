// this file is auto-generated by github.com/grexie/isolates, DO NOT EDIT

package task

import (
  time "time"
  reflect "reflect"
  isolates "github.com/grexie/isolates"
)

var _ = isolates.RegisterRuntime("task", "task.go", func (in isolates.FunctionArgs) (*isolates.Value, error) {
  if constructor, err := in.Context.CreateWithName(in.ExecutionContext, "TaskStats", func (in isolates.FunctionArgs) (*WorkerTaskStats, error) {
    return NewWorkerTaskStats(), nil
  }); err != nil {
    return nil, err
  } else if err := in.Args[1].Set(in.ExecutionContext, "TaskStats", constructor); err != nil {
    return nil, err
  }

  return nil, nil
})

func (t *WorkerTask) V8GetExitCode(in isolates.GetterArgs) (*isolates.Value, error) {
  result := t.ExitCode()
  return in.Context.Create(in.ExecutionContext, result)
}

func (t *WorkerTask) V8FuncWait(in isolates.FunctionArgs) (*isolates.Value, error) {
  if result, err := t.Wait(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *WorkerTask) V8FuncSetTimeout(in isolates.FunctionArgs) (*isolates.Value, error) {
  callback := in.Arg(in.ExecutionContext, 0)
  var duration time.Duration
  if v, __err := in.Arg(in.ExecutionContext, 1).Unmarshal(in.ExecutionContext, reflect.TypeOf(&duration).Elem()); __err != nil {
    return nil, __err
  } else {
    duration = v.Interface().(time.Duration)
  }

  if result, err := c.SetTimeout(callback, duration); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *WorkerTask) V8FuncClearTimeout(in isolates.FunctionArgs) (*isolates.Value, error) {
  var timer int64
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&timer).Elem()); __err != nil {
    return nil, __err
  } else {
    timer = v.Interface().(int64)
  }

  c.ClearTimeout(timer)
  return nil, nil
}

func (c *WorkerTask) V8FuncSetInterval(in isolates.FunctionArgs) (*isolates.Value, error) {
  callback := in.Arg(in.ExecutionContext, 0)
  var duration time.Duration
  if v, __err := in.Arg(in.ExecutionContext, 1).Unmarshal(in.ExecutionContext, reflect.TypeOf(&duration).Elem()); __err != nil {
    return nil, __err
  } else {
    duration = v.Interface().(time.Duration)
  }

  if result, err := c.SetInterval(in.ExecutionContext, callback, duration); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *WorkerTask) V8FuncClearInterval(in isolates.FunctionArgs) (*isolates.Value, error) {
  var ticker int64
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&ticker).Elem()); __err != nil {
    return nil, __err
  } else {
    ticker = v.Interface().(int64)
  }

  c.ClearInterval(ticker)
  return nil, nil
}

func (c *Process) V8FuncCwd(in isolates.FunctionArgs) (*isolates.Value, error) {
  result := c.Cwd()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetEnv(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Env()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetArgs(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Args()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetPlatform(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Platform()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetVersions(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Versions()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetTask(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Task()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetStdout(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Stdout()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetStderr(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Stderr()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetArgv(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Argv()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8GetStdin(in isolates.GetterArgs) (*isolates.Value, error) {
  result := c.Stdin()
  return in.Context.Create(in.ExecutionContext, result)
}

func (c *Process) V8FuncNextTick(in isolates.FunctionArgs) (*isolates.Value, error) {
  if result, err := c.NextTick(in); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *Process) V8FuncExit(in isolates.FunctionArgs) (*isolates.Value, error) {
  var exitCode int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&exitCode).Elem()); __err != nil {
    return nil, __err
  } else {
    exitCode = v.Interface().(int)
  }

  if err := c.Exit(exitCode); err != nil {
    return nil, err
  } else {
    return nil, nil
  }
}

func (c *WorkerTask) V8GetTimeCounter(in isolates.GetterArgs) (*isolates.Value, error) {
  if result, err := c.TimeCounter(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *WorkerTask) V8GetStats(in isolates.GetterArgs) (*isolates.Value, error) {
  if result, err := c.Stats(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}