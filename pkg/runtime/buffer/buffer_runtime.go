// this file is auto-generated by github.com/grexie/isolates, DO NOT EDIT

package buffer

import (
  reflect "reflect"
  isolates "github.com/grexie/isolates"
)

var _ = isolates.RegisterRuntime("buffer", "buffer.go", func (in isolates.FunctionArgs) (*isolates.Value, error) {
  if constructor, err := in.Context.CreateWithName(in.ExecutionContext, "Buffer", func (in isolates.FunctionArgs) (*Buffer, error) {
    return NewBuffer(in)
  }); err != nil {
    return nil, err
  } else if err := in.Args[1].Set(in.ExecutionContext, "Buffer", constructor); err != nil {
    return nil, err
  }

var Module *isolates.Module
Exports := in.Args[1]
Require := in.Args[2]
if m, err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(Module)); err != nil {
  return nil, err
} else {
  Module = m.Interface().(*isolates.Module)
}


  {
    fnName := "createBufferFunction"
    if fn, err := in.Context.CreateFunction(in.ExecutionContext, &fnName, func (in isolates.FunctionArgs) (*isolates.Value, error) {
rin := isolates.RuntimeFunctionArgs{FunctionArgs: in, Module: Module, Exports: Exports, Require: Require}

      if result, err := createBufferFunction(rin); err != nil {
        return nil, err
      } else {
        return in.Context.Create(in.ExecutionContext, result)
      }
    }); err != nil {
      return nil, err
    } else if instance, err := fn.Call(in.ExecutionContext, nil); err != nil {
      return nil, err
    } else if err := in.Args[1].Set(in.ExecutionContext, "Buffer", instance); err != nil {
      return nil, err
    }
  }

  return nil, nil
})

func (b *Buffer) V8GetBuffer(in isolates.GetterArgs) (*isolates.Value, error) {
  result := b.Buffer()
  return in.Context.Create(in.ExecutionContext, result)
}

func (b *Buffer) V8FuncReadUInt32BE(in isolates.FunctionArgs) (*isolates.Value, error) {
  var offset int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&offset).Elem()); __err != nil {
    return nil, __err
  } else {
    offset = v.Interface().(int)
  }

  if result, err := b.ReadUInt32BE(in.ExecutionContext, offset); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *Buffer) V8FuncWriteUInt32BE(in isolates.FunctionArgs) (*isolates.Value, error) {
  var value uint32
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&value).Elem()); __err != nil {
    return nil, __err
  } else {
    value = v.Interface().(uint32)
  }

  var offset int
  if v, __err := in.Arg(in.ExecutionContext, 1).Unmarshal(in.ExecutionContext, reflect.TypeOf(&offset).Elem()); __err != nil {
    return nil, __err
  } else {
    offset = v.Interface().(int)
  }

  if result, err := b.WriteUInt32BE(in.ExecutionContext, value, offset); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (s *bufferStatic) V8FuncConcat(in isolates.FunctionArgs) (*isolates.Value, error) {
  var buffers []*isolates.Value
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&buffers).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    buffers = v.Interface().([]*isolates.Value)
  }

  if result, err := s.Concat(in.ExecutionContext, buffers); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *Buffer) V8FuncSlice(in isolates.FunctionArgs) (*isolates.Value, error) {
  var start *int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&start).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    start = v.Interface().(*int)
  }

  var end *int
  if v, __err := in.Arg(in.ExecutionContext, 1).Unmarshal(in.ExecutionContext, reflect.TypeOf(&end).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    end = v.Interface().(*int)
  }

  if result, err := b.Slice(in.ExecutionContext, start, end); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *Buffer) V8FuncToString(in isolates.FunctionArgs) (*isolates.Value, error) {
  var encoding *BufferEncoding
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&encoding).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    encoding = v.Interface().(*BufferEncoding)
  }

  if result, err := b.ToString(in.ExecutionContext, encoding); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferStatic) V8FuncAlloc(in isolates.FunctionArgs) (*isolates.Value, error) {
  var size int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&size).Elem()); __err != nil {
    return nil, __err
  } else {
    size = v.Interface().(int)
  }

  if result, err := b.Alloc(in.ExecutionContext, size); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferStatic) V8FuncAllocUnsafe(in isolates.FunctionArgs) (*isolates.Value, error) {
  var size int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&size).Elem()); __err != nil {
    return nil, __err
  } else {
    size = v.Interface().(int)
  }

  if result, err := b.AllocUnsafe(in.ExecutionContext, size); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferStatic) V8FuncAllocUnsafeSlow(in isolates.FunctionArgs) (*isolates.Value, error) {
  var size int
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&size).Elem()); __err != nil {
    return nil, __err
  } else {
    size = v.Interface().(int)
  }

  if result, err := b.AllocUnsafeSlow(in.ExecutionContext, size); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferStatic) V8FuncByteLength(in isolates.FunctionArgs) (*isolates.Value, error) {
  var buffer *Buffer
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&buffer).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    buffer = v.Interface().(*Buffer)
  }

  if result, err := b.ByteLength(in.ExecutionContext, buffer); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (s *bufferStatic) V8FuncFrom(in isolates.FunctionArgs) (*isolates.Value, error) {
  args := make([]any, len(in.Args)-0)
  for i, arg := range in.Args[0:] {
    args[i] = arg
  }

  if result, err := s.From(in.ExecutionContext, args...); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferStatic) V8FuncIsBuffer(in isolates.FunctionArgs) (*isolates.Value, error) {
  value := in.Arg(in.ExecutionContext, 0)
  if result, err := b.IsBuffer(in.ExecutionContext, value); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (b *bufferModule) V8GetKMaxLength(in isolates.GetterArgs) (*isolates.Value, error) {
  result := b.MaxLength()
  return in.Context.Create(in.ExecutionContext, result)
}

func (b *bufferModule) V8GetKMaxStringLength(in isolates.GetterArgs) (*isolates.Value, error) {
  result := b.MaxStringLength()
  return in.Context.Create(in.ExecutionContext, result)
}