// this file is auto-generated by github.com/grexie/isolates, DO NOT EDIT

package crypto

import (
  reflect "reflect"
  isolates "github.com/grexie/isolates"
)

var _ = isolates.RegisterRuntime("native:@grexie/workers/crypto", "crypto.go", func (in isolates.FunctionArgs) (*isolates.Value, error) {
  if constructor, err := in.Context.CreateWithName(in.ExecutionContext, "Hash", func (in isolates.FunctionArgs) (*Hash, error) {
    var _algorithm string
    if v, err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&_algorithm).Elem()); err != nil {
      return nil, err
    } else {
      _algorithm = v.Interface().(string)
    }

    return NewHash(_algorithm)
  }); err != nil {
    return nil, err
  } else if err := in.Args[1].Set(in.ExecutionContext, "Hash", constructor); err != nil {
    return nil, err
  }

  return nil, nil
})

func (h *Hash) V8GetAlgorithm(in isolates.GetterArgs) (*isolates.Value, error) {
  result := h.Algorithm()
  return in.Context.Create(in.ExecutionContext, result)
}

func (h *Hash) V8FuncUpdate(in isolates.FunctionArgs) (*isolates.Value, error) {
  var b []byte
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&b).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    b = v.Interface().([]byte)
  }

  if result, err := h.Write(b); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (h *Hash) V8FuncDigest(in isolates.FunctionArgs) (*isolates.Value, error) {
  var b []byte
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&b).Elem()); __err != nil {
    return nil, __err
  } else if v != nil {
    b = v.Interface().([]byte)
  }

  result := h.Sum(b)
  return in.Context.Create(in.ExecutionContext, result)
}