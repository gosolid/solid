// this file is auto-generated by github.com/grexie/isolates, DO NOT EDIT

package keychain

import (
  reflect "reflect"
  isolates "github.com/grexie/isolates"
)

var _ = isolates.RegisterRuntime("keychain", "keychain_darwin.go", func (in isolates.FunctionArgs) (*isolates.Value, error) {
  if _, err := in.Context.CreateWithName(in.ExecutionContext, "Credential", func (in isolates.FunctionArgs) (*CredentialBase, error) {
    return newCredential(in)
  }); err != nil {
    return nil, err
  }

  if _, err := in.Context.CreateWithName(in.ExecutionContext, "Keychain", func (in isolates.FunctionArgs) (*KeychainBase, error) {
    return newKeychain(in)
  }); err != nil {
    return nil, err
  }

  {
    fnName := "newLibrary"
    if fn, err := in.Context.CreateFunction(in.ExecutionContext, &fnName, func (in isolates.FunctionArgs) (*isolates.Value, error) {
      if result, err := newLibrary(in); err != nil {
        return nil, err
      } else {
        return in.Context.Create(in.ExecutionContext, result)
      }
    }); err != nil {
      return nil, err
    } else if instance, err := fn.Call(in.ExecutionContext, nil); err != nil {
      return nil, err
    } else if err := in.Args[1].Set(in.ExecutionContext, "default", instance); err != nil {
      return nil, err
    }
  }

  return nil, nil
})

func (k *KeychainBase) V8FuncCreate(in isolates.FunctionArgs) (*isolates.Value, error) {
  var service string
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&service).Elem()); __err != nil {
    return nil, __err
  } else {
    service = v.Interface().(string)
  }

  if result, err := k.Create(in.ExecutionContext, service); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (k *KeychainBase) V8FuncGet(in isolates.FunctionArgs) (*isolates.Value, error) {
  var service string
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&service).Elem()); __err != nil {
    return nil, __err
  } else {
    service = v.Interface().(string)
  }

  if result, err := k.Get(in.ExecutionContext, service); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (k *KeychainBase) V8FuncHas(in isolates.FunctionArgs) (*isolates.Value, error) {
  var service string
  if v, __err := in.Arg(in.ExecutionContext, 0).Unmarshal(in.ExecutionContext, reflect.TypeOf(&service).Elem()); __err != nil {
    return nil, __err
  } else {
    service = v.Interface().(string)
  }

  if result, err := k.Has(in.ExecutionContext, service); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (k *KeychainBase) V8FuncList(in isolates.FunctionArgs) (*isolates.Value, error) {
  if result, err := k.List(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *CredentialBase) V8GetData(in isolates.GetterArgs) (*isolates.Value, error) {
  if result, err := c.Data(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *CredentialBase) V8GetService(in isolates.GetterArgs) (*isolates.Value, error) {
  if result, err := c.Service(in.ExecutionContext); err != nil {
    return nil, err
  } else {
    return in.Context.Create(in.ExecutionContext, result)
  }
}

func (c *CredentialBase) V8SetData(in isolates.SetterArgs) error {
  var bytes []byte
  if v, err := in.Value.Unmarshal(in.ExecutionContext, reflect.TypeOf(&bytes).Elem()); err != nil {
    return err
  } else if v != nil {
    bytes = v.Interface().([]byte)
  }

  if err := c.SetData(in.ExecutionContext, bytes); err != nil {
    return err
  } else {
    return nil
  }
}